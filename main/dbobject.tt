#pragma once

#include <algorithm>

template <typename KeyType>
bool MetaKey<KeyType>::operator <(const MetaKey<KeyType> &rhs) const
{
    return key_data < rhs.key_data;
}

template <typename KeyType>
bool MetaKey<KeyType>::operator ==(const MetaKey<KeyType> &rhs) const
{
    return key_data == rhs.key_data;
}

template <typename ChildType, typename KeyType>
bool
MappedDBMeta<ChildType, KeyType>::addChild(KeyType key,
                                           ChildType *const meta)
{
    if (childExists(key)) {
        return false;
    }

    children[key] = std::unique_ptr<ChildType>(meta);
    return true;
}

template <typename ChildType, typename KeyType>
typename std::map<KeyType, std::unique_ptr<ChildType>>::const_iterator
MappedDBMeta<ChildType, KeyType>::findChild(const KeyType &key) const
{
    auto it = children.find(key);
    assert(it != children.end());

    return it;
}

template <typename ChildType, typename KeyType>
bool
MappedDBMeta<ChildType, KeyType>::childExists(const KeyType &key) const
{
    return children.end() != this->findChild(key);
}

// Slow.
// FIXME: Use findChild.
template <typename ChildType, typename KeyType>
ChildType *
MappedDBMeta<ChildType, KeyType>::getChild(const KeyType &key) const
{
    for (auto it = children.begin(); it != children.end(); it++) {
        if (it->first == key) {
            return it->second.get();
        }
    }

    return NULL;
}

// NOTE: Slow.
template <typename ChildType, typename KeyType>
KeyType const &
MappedDBMeta<ChildType, KeyType>::getKey(const DBMeta &child) const
{
    for (auto it = children.begin(); it != children.end(); ++it) {
        if (it->second.get() == &child) {
            return (*it).first;
        }
    }

    assert(false);
}

template <typename ChildType, typename KeyType>
std::vector<DBMeta *>
MappedDBMeta<ChildType, KeyType>::fetchChildren(const std::unique_ptr<Connect> &e_conn)
{
    // Perhaps it's conceptually cleaner to have this lambda return
    // pairs of keys and children and then add the children from local
    // scope.
    std::function<DBMeta *(const std::string &,
                           const std::string &,
                           const std::string &)>
        deserialize =
        [this] (const std::string &key, const std::string &serial,
                const std::string &id)
        {
            const KeyType *const meta_key =
                AbstractMetaKey::factory<KeyType>(key);
            auto dChild = ChildType::deserialize;
            std::unique_ptr<ChildType> new_old_meta(dChild(atoi(id.c_str()),
                                          serial));

            // Gobble the child.
            // FIXME: URGENT.
            this->addChild(*meta_key, new_old_meta.get());

            // FIXME: URGENT.
            return new_old_meta.get();
        };

    return DBMeta::doFetchChildren(e_conn, deserialize);
}

template <typename ChildType, typename KeyType>
void
MappedDBMeta<ChildType, KeyType>::applyToChildren(std::function<void(const DBMeta &)> fn) const
{
    for (auto it = children.begin(); it != children.end(); it++) {
        fn(*(*it).second.get());
    }
}

